这是一份关于 **Proximity-1 协议同步与编码子层（CSS）** 数据流转的详细技术报告。

基于已经完成的代码（`scs_transmitter` + `ldpc_encoder`），数据经历了三个核心阶段的变化：**封装（Encapsulation）** $\to$ **流化（Streaming）** $\to$ **编码（Coding）**。

下面分层剖析每一比特的来源和去向。

---

### 第一阶段：PLTU 封装层 (Data Link Layer Interface)

这一层处理的是离散的“帧”。它的目标是给原始数据加上“信封”，使其在解码后能被识别边界并校验完整性。

#### 1. 输入

* **Transfer Frame (传送帧)**：来自上层（数据链路协议子层）的原始数据。
* 长度：设为 $L_{frame}$ (bits)。必须是 8 的倍数。

#### 2. 操作

1. **CRC-32 计算**：对 $L_{frame}$ 计算 32 位校验码。
2. **ASM 插入**：在头部加入 24 位同步标记（`0xFAF320`）。

#### 3. 输出结构：PLTU

```text
|   ASM   |      Transfer Frame      |   CRC-32   |
| 24 bits |      L_frame bits        |  32 bits   |
```

#### 4. 开销分析

* **固定开销**：$24 + 32 = \mathbf{56 \text{ bits}}$。
* **总长度**：$L_{PLTU} = L_{frame} + 56$。

---

### 第二阶段：数据流生成层 (Stream Generation)

这一层负责将离散的 PLTU 变成连续的、符合 LDPC 块长度要求的比特流。这是 `scs_transmitter` 函数的核心工作。

#### 1. 输入

* 一个或多个 **PLTU**。

#### 2. 操作

1. **捕获序列 (Acquisition Seq)**：开头插入一段空闲序列（如 64/128 bits），用于接收机锁相。
2. **拼接**：将 PLTU 首尾相连。
3. **空闲填充 (Idle Data)**：在 PLTU 之间（可选）或没有数据时插入空闲序列。
4. **尾序列 (Tail Seq)**：结束时插入空闲序列。
5. **块对齐填充 (Block Padding)**：**这是关键一步**。
   * LDPC 编码器要求输入必须是 $k=1024$ 的整数倍。
   * 系统计算当前总长度，补足 $(1024 - \text{余数})$ 个空闲比特。

#### 3. 输出结构：对齐的数据流 (Raw Stream)

```text
[Acq Seq] + [PLTU 1] + [Idle] + [PLTU 2] + ... + [Tail Seq] + [Padding]
```

**总长度**：严格等于 $N \times 1024$ bits。

---

### 第三阶段：LDPC 信道编码层 (Channel Coding)

这一层将“无保护”的数据流转化为“强抗噪”的物理层符号流。这是 `ldpc_encoding_chain` 的工作。

#### 1. 输入

* **切片 (Slicing)**：将上面的长数据流切分为若干个 **1024 bits** 的信息块 (Information Block)。
  * *注意：切片是“无情”的，它不管你切的位置是在 PLTU 中间，还是在 ASM 上。它只认 1024 bits。*

#### 2. 操作 (针对每个 1024 bit 块)

1. **LDPC 编码**：
   * 输入：1024 bits。
   * 中间产物：2560 bits (512 x 5)。
   * **打孔 (Puncturing)**：丢弃最后 512 bits。
   * 输出码字：**2048 bits** (Rate 1/2)。
2. **随机化 (Randomization)**：
   * 对这 2048 bits 进行加扰（XOR 伪随机序列），保持 0/1 平衡。
3. **CSM 插入 (Code Sync Marker)**：
   * 在每个码字前加入 **64 bits** 的 CSM (`0x034776C7272895B0`)。
   * *注意：这里是 64位 CSM，不同于 PLTU 的 24位 ASM。*

#### 3. 输出结构：物理信道符号 (Channel Symbols)

每个编码块（Codeblock）的结构如下：

```text
|   CSM   |   Randomized LDPC Codeword (Systematic + Parity)   |
| 64 bits |   1024 bits (原数据)   +   1024 bits (校验数据)    |
```

**单块总长度**：$64 + 2048 = \mathbf{2112 \text{ bits}}$。

---

### 总结：从输入到输出的比特账单

假设我们发送 **1 个** 长度为 **100 字节 (800 bits)** 的 Transfer Frame，配置如下：

* Acq/Tail Seq: 各 64 bits。
* Idle: 0 bits。
* LDPC Rate: 1/2。

#### 账单计算表

| 步骤    | 操作          | 增加比特                    | 当前总长度 (bits)           | 说明                   |
|:----- |:----------- |:----------------------- |:---------------------- |:-------------------- |
| **0** | **原始帧**     | -                       | **800**                | 用户数据                 |
| **1** | **PLTU 封装** | +24 (ASM)<br>+32 (CRC)  | 800 + 56 = **856**     | 形成 PLTU              |
| **2** | **流控制**     | +64 (Acq)<br>+64 (Tail) | 856 + 128 = **984**    | 加上头尾序列               |
| **3** | **LDPC 对齐** | +40 (Padding)           | 984 + 40 = **1024**    | 补齐到 1024 的倍数 (凑够1个块) |
| **4** | **LDPC 编码** | +1024 (Parity)          | 1024 + 1024 = **2048** | 码率 1/2，长度翻倍          |
| **5** | **物理层成帧**   | +64 (CSM)               | 2048 + 64 = **2112**   | 插入 LDPC 专用同步头        |

#### 最终效率分析

* **有效数据**：800 bits。
* **实际发送**：2112 bits。
* **传输效率**：$800 / 2112 \approx \mathbf{37.8\%}$。

### 关键结论

1. **双重同步机制**：
   
   * **CSM (64 bit)**：用于物理层，告诉接收机“这是一个 LDPC 码块的开始”。
   * **ASM (24 bit)**：用于数据链路层，告诉接收机“这是一个数据帧的开始”。
   * *即使 ASM 位于 LDPC 码块的中间，接收机在解码出 LDPC 数据后，依然能通过搜索 ASM 找到帧。*

2. **编码代价**：
   
   * 使用 Rate 1/2 LDPC 码，数据量至少翻倍。
   * 加上 CSM 开销，带宽占用约为原始数据的 **2.1 倍** 左右。
   * **收益**：换来的是极强的纠错能力，能在极低信噪比（接近香农极限）下通信。

代码 `scs_transmitter` 和 `ldpc_encoder` 正是完美地执行了上述所有步骤。
