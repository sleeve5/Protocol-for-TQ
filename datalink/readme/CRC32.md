

### 1. 核心定位：检错而非纠错

在 Proximity-1 协议栈中，LDPC（或卷积码）负责**信道编码**，主要目标是**纠错 (Error Correction)**，即在噪声中恢复出原始数据。

而 CRC-32 位于 PLTU 的尾部，它的职责是**检错 (Error Detection)**。

* **最后的防线**：如果信道噪声太强，导致 LDPC 译码器输出错误（且译码器没能检测出自己错了），CRC 是最后一道关卡。
* **残余误码率 (Undetected Error Rate)**：32 位的 CRC 能将未检测到的错误概率降低到 $2^{-32}$ 数量级，确保交给上层的数据几乎绝对可靠。

---

### 2. 数学构造：多项式环上的除法

CRC 的核心数学原理是 **GF(2) 域上的多项式除法**。

#### (1) 生成多项式 $G(X)$

你的代码中定义了：

```matlab
CRC_POLY_HEX = '00A00805';
```

这对应于标准（Annex C）中的公式：
$$ G(X) = X^{32} + X^{23} + X^{21} + X^{11} + X^2 + 1 $$

**理论拆解：**
让我们把你的 Hex 值 `00A00805` 展开成二进制，看看它如何对应数学公式：

* `00A0` = `0000 0000 1010 0000` (Bits 31-16) $\to$ 对应 Bit 23, 21。
* `0805` = `0000 1000 0000 0101` (Bits 15-0)  $\to$ 对应 Bit 11, 2, 0。
* **隐式最高位**：$X^{32}$ 系数永远是 1，通常在计算机表示中被省略（因为寄存器只有 32 位）。
* **结论**：你的代码精确地映射了标准规定的稀疏多项式。

#### (2) 编码过程：系统码构建

CRC 也是一种线性分组码，且是系统码。其数学生成过程如下：

设原始数据（Transfer Frame）为多项式 $M(X)$。

1. **移位**：将数据左移 32 位，即 $M(X) \cdot X^{32}$。这相当于在数据后面补 32 个 0，为存放 CRC 留出空间。
2. **模2除法**：用生成多项式 $G(X)$ 去除移位后的数据。
   $$ \frac{M(X) \cdot X^{32}}{G(X)} = Q(X) + \frac{R(X)}{G(X)} $$
   其中 $Q(X)$ 是商（不重要），$R(X)$ 是**余数 (Remainder)**。
3. **生成码字**：$R(X)$ 就是 CRC 校验码。
   $$ C(X) = M(X) \cdot X^{32} + R(X) $$
   在 GF(2) 域中，加法等于减法（都是异或 XOR）。所以，$C(X)$ 必然能被 $G(X)$ 整除。

**接收端原理**：接收方收到数据后，再次除以 $G(X)$。如果余数为 0，说明数据无误；否则，说明发生了翻转。

---

### 3. 工程实现

 **Proximity-1 的具体配置与以太网 (IEEE 802.3) 完全不同**。

| 特性                    | 标准 Ethernet CRC-32    | **Proximity-1 CRC-32 **       | **原因**                                                  |
|:--------------------- |:--------------------- |:----------------------------- |:------------------------------------------------------- |
| **初始状态 (Init State)** | `0xFFFFFFFF` (全1)     | **`0x00000000` (全0)**         | 以太网用全1是为了检测头部连0丢失。Proximity-1 有 ASM 定帧，不需要 CRC 来检测开头丢失。 |
| **结果异或 (Final XOR)**  | `0xFFFFFFFF` (取反)     | **`0x00000000` (直出)**         | 不对结果取反，简化了星上硬件逻辑。                                       |
| **输入/输出位序**           | Reflected (LSB First) | **Not Reflected (MSB First)** | 空间链路协议通常遵循大端序 ($b_0$ 先发)，你的代码中 `hex2bit_MSB` 完美契合了这一点。  |

**你的代码验证：**

```matlab
crcGen = comm.CRCGenerator( ...
    'Polynomial', CRC_POLY_VECTOR, ... 
    'InitialConditions', 0, ...       % 对应全0初始化
    'DirectMethod', true);            % 对应不进行 Input/Output Reflection
```

---

### 4. 检错能力：它能防住什么？

为什么选这个特定的 32 阶多项式？

1. **汉明距离 (Hamming Distance)**：对于最大长度为 2048 字节 (16384 bits) 的帧，该 CRC 保证了汉明距离 $d_{min} \ge 4$。这意味着它能百分之百检测出任意 **3 个比特的随机错误**。
2. **突发错误 (Burst Error)**：它能检测出所有长度 $\le 32$ 位的突发错误（即一段连续的错误序列）。这对于应对信道中的短时脉冲干扰非常有效。
3. **奇数个错误**：由于多项式包含 $(X+1)$ 因子（或具有偶数项），它能检测出所有奇数个比特翻转。

---

### 5. 与 ASM 的关系

在 `build_PLTU` 和 `CRC32` 函数中，有一个非常重要的**物理层/链路层分界**细节，通过标准文档 Annex C 的 Note 2 得到印证：

* 先计算 Transfer Frame 的 CRC，把它们拼接起来，**最后** 再在前面加上 ASM。
  
  ```matlab
  PLTU = [ASM_bit, frame_data, crc_code];
  ```
* **理论意义**：
  ASM（同步标志）属于物理层/同步层的机制，用于告诉接收机“数据从这里开始”。而 CRC 是数据链路层的机制，用于保护“数据本身”。
  如果在 CRC 计算中包含 ASM，一旦 ASM 在物理层检测中出现位滑移或错误，CRC 就会报错，导致整个帧被丢弃。将二者解耦，使得只要 ASM 能被识别（哪怕有一两个错），后续的数据依然有机会通过 CRC 校验。

---
