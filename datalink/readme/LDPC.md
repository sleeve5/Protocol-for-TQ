### 1. 核心定位：为什么是 C2 LDPC？

在 CCSDS 体系中，LDPC 码主要分两类：

1. **AR4JA (深空类)**：用于极远距离（如火星到地球），主要追求极致的信噪比门限。
2. **C2 (近地/邻近链路类)**：**Proximity-1 使用的是这一类**。

**理论特点：**

* **高增益**：比传统的卷积码（Viterbi译码）高出约 1.5 - 2 dB 的编码增益，这意味着在同样的发射功率下，传输距离可以增加约 50%。
* **准循环 (Quasi-Cyclic, QC)**：这是工程实现的关键。一般的 LDPC 码校验矩阵 $H$ 是巨大的随机稀疏矩阵，存储和布线极难。C2 码通过“循环移位”构造，使得硬件（FPGA/ASIC）可以通过简单的移位寄存器并行处理，极大降低了复杂度。

---

### 2. 数学构造：校验矩阵 H 的奥秘

LDPC 码的核心在于校验矩阵 $H$。对于 Proximity-1 (Rate 1/2, k=1024)，这个矩阵的构造非常精妙。

#### (1) 基础参数

* **信息位 $k = 1024$**。
* **子矩阵大小 $M = 512$**（这是基本颗粒度）。
* **码率构造**：它实际上是基于一个更低码率的原型构建，然后通过**打孔 (Puncturing)** 得到 1/2 码率。

#### (2) 矩阵方程 (代码背后的数学)

你在代码中实现的矩阵拼接逻辑，源自 CCSDS 131.0-B-5 标准公式：

$$ H_{1/2} = \begin{bmatrix} 0_M & 0_M & I_M & 0_M & I_M \oplus \Pi_1 \\ I_M & I_M & 0_M & I_M & \Pi_2 \oplus \Pi_3 \oplus \Pi_4 \\ I_M & \Pi_5 \oplus \Pi_6 & 0_M & \Pi_7 \oplus \Pi_8 & I_M \end{bmatrix} $$

**理论解读：**

* **矩阵维度**：$3 \times 5$ 个子块。总尺寸为 $(3 \times 512) \times (5 \times 512) = 1536 \times 2560$。
* **稀疏性**：绝大多数子块是 $0_M$ 或 $I_M$。
* **置换矩阵 $\Pi_k$ (Pi Matrices)**：这是 C2 码的灵魂。
  * AR4JA 码使用的是简单的“循环移位”（Circulant），即单位矩阵向右移位 $S$ 次。
  * **C2 码使用的是“代数置换”**。代码中复杂的 `generate_permutation_matrix` 函数，实际上是在计算一个基于模运算的映射 $\pi(i)$。
  * **作用**：这种复杂的置换是为了打断循环结构中的短环（Short Cycles），特别是避免 4 环（Girth 4），尽量保证 **Girth $\ge$ 6**。这能让译码算法（置信传播 BP）收敛得更好，没有“错误平层 (Error Floor)”。

---

### 3. 编码原理：从矩阵到比特流

线性分组码的核心定义是：对于码字 $C$，必须满足 $C \cdot H^T = 0$（在 GF(2) 域下）。

#### (1) 系统码 (Systematic Code)

Proximity-1 的 LDPC 是系统码。这意味着生成的 2560 bits 中：

* **前 1024 bits** 是原始数据（不做任何修改，直接拷贝）。
* **后 1536 bits** 是根据 $H$ 矩阵计算出来的校验位。

这就是为什么代码可以直接把输入数据填入编码器，输出的前半部分和输入一样。

#### (2) 打孔 (Puncturing) —— 为什么代码里要丢弃最后 512 位？

这是一个非常重要的理论概念。

* **原始矩阵**：$H$ 是 $1536 \times 2560$。
  * 变量节点（总比特数）= 2560。
  * 校验节点（约束方程）= 1536。
  * 原始码率 $R \approx (2560 - 1536) / 2560 = 1024 / 2560 = 0.4$。
* **目标码率**：1/2。
* **实现方法**：
  标准规定：“**Last $M$ columns shall be punctured.**”
  即生成 2560 bits 后，**不发送**最后的 $M=512$ bits。
  * 发送长度 $n = 2560 - 512 = 2048$。
  * 信息长度 $k = 1024$。
  * 最终码率 $R = 1024 / 2048 = 1/2$。

**理论意义**：打孔后的比特虽然没发，但在接收端的译码图中，它们被视为“被擦除的节点”（Erasure，初始对数似然比 LLR = 0）。译码器依然会推断这些节点的值，利用它们来辅助校验其他节点。

---

### 4. 译码原理：置信传播 (Belief Propagation)

虽然目前只写了发送端，但理解接收端原理对理解参数很有帮助。

LDPC 的译码是在 **Tanner 图** 上进行的：

1. **变量节点 (Variable Nodes)**：代表接收到的 2048 个比特（加上被打孔的 512 个虚拟比特）。
2. **校验节点 (Check Nodes)**：代表 1536 个校验方程。
3. **边 (Edges)**：如果 $H_{i,j}=1$，则校验节点 $i$ 和变量节点 $j$ 相连。

**过程**：

* 变量节点告诉校验节点：“根据接收到的信号，我有 90% 的概率是 1”。
* 校验节点根据连接的所有变量节点计算：“为了满足偶校验，如果其他人是那样，那你必须是 0”。
* 反复迭代。

**C2 码的优势**：由于 $\Pi_k$ 矩阵的设计，Tanner 图的连接非常混乱（伪随机），这使得错误信息能快速在全图扩散并被纠正，这就是它逼近香农极限的原因。

---

### 5. 物理层辅助机制

纯粹的数学 LDPC 码很脆弱，需要两个物理层机制保护：

#### (1) 随机化 (Randomization)

* **问题**：LDPC 是系统码。如果你发全 0 数据，码字的前半部分全是 0。如果校验部分也恰好 0 多，信号就会出现长时间没有电平跳变（Long string of zeros），导致接收机**位同步 (Bit Sync)** 失锁。
* **解决**：在 LDPC 编码后，加上伪随机序列（PN Sequence）。
* **理论**：这被称为“频谱白化 (Spectral Whitening)”，保证信号频谱平坦，且有足够的跳变供接收机锁定时钟。

#### (2) CSM (码字同步标志)

* **问题**：LDPC 译码必须知道**精确的**码字起始位置。错一位，整个矩阵方程就不成立了。
* **解决**：普通的 ASM 只是用来定帧的。在 Proximity-1 中，由于可能存在 LDPC 码块和传输帧不一一对应的情况（Slice 模式），或者为了更高精度的物理层同步，引入了 **CSM (Code Sync Marker)**。
* **理论**：CSM 是一个强自相关序列，接收机通过相关运算（Correlation）在巨大的噪声中找到 LDPC 码块的“头”。
